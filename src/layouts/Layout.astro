---
import { SEO } from "astro-seo";
import "uno.css";
import siteConfig from "../side.config";

export interface Props {
	title?: string;
	description?: string;
	image?: string;
}

const { title, description, image } = Astro.props;

// SEO-related variables
const seoTitle = title ? `${title} | ${siteConfig.title}` : siteConfig.title;
const seoDesc = description || siteConfig.description;
// Assumes a default OG image is specified in siteConfig, with a fallback.
const ogImage = image || '/profile.svg';

const currentYear = new Date().getFullYear();
const siteTitle = siteConfig.author || siteConfig.title;


---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="icon" type="image/svg+xml" href={siteConfig.favicon} />
		<meta name="description" content={siteConfig.description} />
		<meta name="keywords" content={siteConfig.keywords.join(', ')} />
		<meta name="generator" content={Astro.generator} />
		<title>{siteConfig.title}</title>
		<link rel="sitemap" href="/sitemap-index.xml" />

    <SEO
      title={seoTitle}
      description={seoDesc}
      openGraph={{
        basic: {
          title: seoTitle,
          type: 'website',
          image: ogImage,
        },
      }}
      extend={{
        link: [{ rel: 'icon', href: siteConfig.favicon }],
        meta: [{ name: 'keywords', content: siteConfig.keywords.join(', ') }],
      }}
    />
		<slot name="head" />
	</head>
	<body class="min-h-screen bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-100 font-sans transition-colors">
		<div class="mx-auto flex min-h-screen max-w-4xl flex-col px-5 py-8 md:px-10">
			      <header
        class="relative flex flex-wrap items-center justify-between gap-y-4 p-4 mb-12 md:flex-nowrap md:gap-x-8 md:p-0 md:mb-16"
      >
        <a
          data-site-title
          class="font-heading font-semibold text-slate-900 dark:text-slate-100 text-2xl md:text-3xl no-underline whitespace-nowrap md:order-1"
          href="/"
        >
          {siteTitle}
        </a>
        <div data-actions class="flex items-center gap-3 md:order-3">
          <div data-overflow-container class="relative">
            <button
              type="button"
              data-overflow-toggle
              class="inline-flex h-10 w-10 items-center justify-center rounded-full bg-slate-200/80 text-slate-700 transition-colors duration-200 hover:bg-accent-100 hover:text-accent-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-200/60 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-50 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:bg-accent-500/20 dark:hover:text-accent-200 dark:focus-visible:ring-offset-slate-950"
              aria-expanded="false"
              aria-haspopup="true"
              hidden
            >
              <span class="sr-only">Open navigation menu</span>
              <span class="i-ph-list-bold text-lg" aria-hidden="true"></span>
            </button>
            <ul
              data-overflow-menu
              class="hidden absolute right-0 top-full mt-3 min-w-[180px] list-none rounded-xl border border-slate-200 bg-white p-2 shadow-lg dark:border-slate-700 dark:bg-slate-900"
            >
            </ul>
          </div>
          <button
            type="button"
            data-theme-toggle
            class="inline-flex h-10 w-10 items-center justify-center rounded-full bg-gradient-to-br from-accent-400 via-accent-500 to-accent-600 text-white shadow-[0_10px_18px_rgba(55,0,179,0.25)] transition-all duration-200 hover:shadow-[0_14px_22px_rgba(55,0,179,0.3)] hover:scale-110 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-200/60 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-50 dark:from-accent-500 dark:via-accent-400 dark:to-accent-500 dark:focus-visible:ring-offset-slate-950"
            aria-label="Toggle color mode"
          >
            <span class="sr-only">Toggle color mode</span>
            <span
              class="i-ph-moon-stars-duotone text-lg block dark:hidden"
              aria-hidden="true"></span>
            <span
              class="i-ph-sun-dim-duotone text-lg hidden dark:block"
              aria-hidden="true"></span>
          </button>
        </div>
        <nav
          class="w-full order-last md:w-auto md:order-2 md:flex-1 md:min-w-0 md:overflow-hidden"
        >
          <ul
            data-nav-list
            class="flex flex-wrap items-center justify-center gap-3 m-0 p-0 list-none md:justify-end"
          >
            {
              siteConfig.navLinks.map((link) => (
                <li data-nav-item>
                  <a
                    class="block no-underline text-slate-600 dark:text-slate-300 font-medium px-4 py-2 rounded-full transition-colors duration-200 hover:bg-accent-100 hover:text-accent-700 dark:hover:bg-accent-500/20 dark:hover:text-accent-200"
                    href={link.href}
                  >
                    {link.label}
                  </a>
                </li>
              ))
            }
          </ul>
        </nav>
      </header>

			<main class="flex-1 space-y-10 md:space-y-12">
				<slot />
			</main>

			<footer class="mt-10 border-t border-slate-200 pt-6 text-sm text-slate-500 dark:border-slate-800 dark:text-slate-400 md:mt-16">
				<p class="m-0 text-center md:text-left">
					&copy; {`${currentYear} ${siteConfig.author}. ${siteConfig.footer.copyright}`}
				</p>
			</footer>
		</div>

		<script is:inline>
      (() => {
        // --- Theme management ---
        const STORAGE_KEY = "site-theme";
        const getStored = () => {
          try {
            return localStorage.getItem(STORAGE_KEY);
          } catch (err) {
            return null;
          }
        };

        const applyTheme = (mode) => {
          if (mode === "dark") {
            document.documentElement.classList.add("dark");
          } else {
            document.documentElement.classList.remove("dark");
          }
        };

        const stored = getStored();
        if (stored) {
          applyTheme(stored);
        } else if (
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
        ) {
          applyTheme("dark");
        }

        // --- Event Listeners ---
        document.addEventListener("DOMContentLoaded", () => {
          // Theme toggle buttons
          const toggleButtons = document.querySelectorAll(
            "[data-theme-toggle]"
          );
          toggleButtons.forEach((btn) => {
            btn.addEventListener("click", () => {
              const isDark = document.documentElement.classList.toggle("dark");
              try {
                localStorage.setItem(STORAGE_KEY, isDark ? "dark" : "light");
              } catch (err) {
                /* ignore */
              }
            });
          });

          // System theme change
          if (window.matchMedia) {
            window
              .matchMedia("(prefers-color-scheme: dark)")
              .addEventListener("change", (event) => {
                if (!getStored()) {
                  applyTheme(event.matches ? "dark" : "light");
                }
              });
          }

          // --- Navigation overflow management ---
          const navList = document.querySelector("[data-nav-list]");
          const overflowMenu = document.querySelector("[data-overflow-menu]");
          const overflowToggle = document.querySelector(
            "[data-overflow-toggle]"
          );
          const actions = document.querySelector("[data-actions]");
          if (navList && overflowMenu && overflowToggle && actions) {
            const navItems = Array.from(
              navList.querySelectorAll("[data-nav-item]")
            );
            const setMenuItemMode = (item, inMenu) => {
              item.classList.toggle("w-full", inMenu);
              const link = item.querySelector("a");
              if (!link) {
                return;
              }
              link.classList.toggle("text-left", inMenu);
              link.classList.toggle("rounded-lg", inMenu);
              link.classList.toggle("rounded-full", !inMenu);
              link.classList.toggle("px-4", !inMenu);
              link.classList.toggle("px-2", inMenu);
            };
            const closeOverflowMenu = () => {
              overflowMenu.classList.add("hidden");
              overflowToggle.setAttribute("aria-expanded", "false");
            };
            const openOverflowMenu = () => {
              if (!overflowMenu.children.length) {
                return;
              }
              overflowMenu.classList.remove("hidden");
              overflowToggle.setAttribute("aria-expanded", "true");
            };
            const hideOverflowToggle = () => {
              if (!overflowToggle.hidden) {
                overflowToggle.hidden = true;
              }
              overflowToggle.setAttribute("aria-hidden", "true");
              overflowToggle.tabIndex = -1;
              closeOverflowMenu();
            };
            const showOverflowToggle = () => {
              if (overflowToggle.hidden) {
                overflowToggle.hidden = false;
              }
              overflowToggle.setAttribute("aria-hidden", "false");
              overflowToggle.tabIndex = 0;
            };

            const updateOverflow = () => {
              // First, put everything back in the main nav list to get a baseline
              navItems.forEach((item) => {
                if (item.parentElement !== navList) {
                  setMenuItemMode(item, false);
                  navList.appendChild(item);
                }
              });

              const itemHeight = navItems[0] ? navItems[0].offsetHeight : 0;
              const isWrapping = () =>
                itemHeight > 0 && navList.offsetHeight > itemHeight * 1.5;

              if (isWrapping()) {
                // If it's wrapping, show the toggle and move ALL items to the menu
                showOverflowToggle();
                closeOverflowMenu(); // Ensure it's closed before moving items

                // Move all children from navList to overflowMenu, maintaining order
                while (navList.firstElementChild) {
                  const item = navList.firstElementChild;
                  setMenuItemMode(item, true);
                  overflowMenu.appendChild(item);
                }
              } else {
                // If it's not wrapping, hide the toggle and ensure the menu is empty
                hideOverflowToggle();
                closeOverflowMenu();
              }
            };

            setTimeout(updateOverflow, 50);

            if ("ResizeObserver" in window) {
              const observer = new ResizeObserver(() => {
                window.requestAnimationFrame(updateOverflow);
              });
              observer.observe(navList);
            } else {
              window.addEventListener("resize", () => {
                window.requestAnimationFrame(updateOverflow);
              });
            }

            overflowToggle.addEventListener("click", (event) => {
              event.stopPropagation();
              if (overflowMenu.classList.contains("hidden")) {
                openOverflowMenu();
              } else {
                closeOverflowMenu();
              }
            });

            document.addEventListener("click", (event) => {
              if (!actions.contains(event.target)) {
                closeOverflowMenu();
              }
            });

            document.addEventListener("keydown", (event) => {
              if (event.key === "Escape") {
                closeOverflowMenu();
              }
            });
          }
        });
      })();
		</script>
	</body>
</html>
